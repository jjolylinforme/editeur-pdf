<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>√âditeur PDF - Effacement Simple</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen p-6">

<div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-xl p-8">
  <h1 class="text-3xl font-bold text-center text-gray-800 mb-2 font-sans">Effaceur PDF</h1>
  <p class="text-center text-gray-600 mb-8">Cliquez et glissez pour effacer. D√©placez les blocs ou cliquez sur (X) pour annuler.</p>

  <div id="upload-zone" class="border-2 border-dashed border-indigo-300 rounded-xl p-12 text-center cursor-pointer hover:border-indigo-500 hover:bg-indigo-50 transition-all">
    <p class="text-lg font-medium text-gray-700 mb-2 font-sans">Cliquez pour charger votre PDF</p>
    <p class="text-sm text-gray-500">Le fichier reste sur votre ordinateur</p>
    <input type="file" id="pdfInput" accept=".pdf" class="hidden">
  </div>

  <div id="viewer" class="hidden mt-8">
    <div class="flex justify-between items-center mb-4 px-2">
      <div class="flex gap-2">
        <button id="prevPage" class="bg-gray-100 hover:bg-gray-200 px-4 py-1 rounded-lg border font-bold text-gray-700 transition-colors">‚Üê</button>
        <button id="nextPage" class="bg-gray-100 hover:bg-gray-200 px-4 py-1 rounded-lg border font-bold text-gray-700 transition-colors">‚Üí</button>
      </div>
      <span id="pageInfo" class="text-gray-700 font-bold font-mono bg-gray-50 px-3 py-1 rounded-md border">Page 1/1</span>
    </div>

    <div class="bg-gray-200 rounded-xl overflow-auto flex justify-center border-4 border-gray-100 shadow-inner" style="max-height:600px;">
      <div style="position: relative;" class="my-4">
        <canvas id="pdfCanvas" class="shadow-lg"></canvas>
        <canvas id="overlayCanvas" style="position:absolute;top:0;left:0;"></canvas>
      </div>
    </div>

    <div class="mt-6 space-y-4">
      <div class="flex items-center gap-4 bg-indigo-50 p-3 rounded-lg border border-indigo-100">
        <label class="flex items-center cursor-pointer">
          <input type="checkbox" id="applyToAll" checked class="w-5 h-5 text-indigo-600 rounded mr-3 focus:ring-indigo-500">
          <span class="text-sm font-medium text-gray-700 font-sans">Appliquer ces effacements sur toutes les pages</span>
        </label>
      </div>

      <button id="downloadPDF" class="w-full py-4 rounded-xl font-bold text-white bg-indigo-600 hover:bg-indigo-700 shadow-lg flex items-center justify-center transition-all transform hover:scale-[1.01] active:scale-[0.99] uppercase tracking-wider">
        üíæ T√©l√©charger le PDF effac√©
      </button>
    </div>
  </div>
</div>

<script>
const pdfInput = document.getElementById('pdfInput');
const uploadZone = document.getElementById('upload-zone');
const viewer = document.getElementById('viewer');
const pdfCanvas = document.getElementById('pdfCanvas');
const overlayCanvas = document.getElementById('overlayCanvas');
const overlayCtx = overlayCanvas.getContext('2d');
const prevPageBtn = document.getElementById('prevPage');
const nextPageBtn = document.getElementById('nextPage');
const pageInfo = document.getElementById('pageInfo');
const applyToAllCheckbox = document.getElementById('applyToAll');
const downloadBtn = document.getElementById('downloadPDF');

let pdfDoc = null, pdfFile = null, currentPage = 1, totalPages = 0, scale = 1.3;
let zones = {}, isDrawing = false, isDragging = false;
let startX = 0, startY = 0, offsetX = 0, offsetY = 0, activeZone = null;

uploadZone.onclick = () => pdfInput.click();
pdfInput.onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  pdfFile = file;
  const arrayBuffer = await file.arrayBuffer();
  pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  totalPages = pdfDoc.numPages;
  viewer.classList.remove('hidden');
  uploadZone.classList.add('hidden');
  renderPage(1);
};

async function renderPage(num) {
  const page = await pdfDoc.getPage(num);
  const viewport = page.getViewport({ scale });
  pdfCanvas.width = overlayCanvas.width = viewport.width;
  pdfCanvas.height = overlayCanvas.height = viewport.height;
  await page.render({ canvasContext: pdfCanvas.getContext('2d'), viewport }).promise;
  draw();
  pageInfo.textContent = `Page ${num}/${totalPages}`;
}

function draw() {
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  const pageZones = zones[currentPage] || [];
  
  pageZones.forEach(z => {
    // Bloc d'effacement blanc
    overlayCtx.fillStyle = 'white';
    overlayCtx.shadowBlur = 4;
    overlayCtx.shadowColor = 'rgba(0,0,0,0.15)';
    overlayCtx.fillRect(z.x, z.y, z.w, z.h);
    overlayCtx.shadowBlur = 0;
    
    // Bordure de pr√©visualisation
    overlayCtx.strokeStyle = '#6366f1'; // Indigo
    overlayCtx.lineWidth = 1;
    overlayCtx.strokeRect(z.x, z.y, z.w, z.h);

    // Bouton de suppression (X)
    overlayCtx.fillStyle = '#ef4444';
    overlayCtx.fillRect(z.x + z.w - 20, z.y, 20, 20);
    overlayCtx.fillStyle = 'white';
    overlayCtx.font = 'bold 14px Arial';
    overlayCtx.fillText('√ó', z.x + z.w - 15, z.y + 15);
  });
}

const getPos = (e) => {
  const r = overlayCanvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
};

overlayCanvas.onmousedown = e => {
  const { x, y } = getPos(e);
  const pageZones = zones[currentPage] || [];

  // Suppression via le bouton (X)
  const zoneToDelete = pageZones.find(z => x >= z.x + z.w - 20 && x <= z.x + z.w && y >= z.y && y <= z.y + 20);
  if (zoneToDelete) {
    zones[currentPage] = pageZones.filter(z => z !== zoneToDelete);
    draw();
    return;
  }

  // D√©placement d'un bloc existant
  const clickedZone = pageZones.find(z => x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h);
  if (clickedZone) {
    activeZone = clickedZone;
    isDragging = true;
    offsetX = x - clickedZone.x;
    offsetY = y - clickedZone.y;
  } else {
    // Cr√©ation d'un nouveau bloc
    isDrawing = true;
    startX = x; startY = y;
    activeZone = { x, y, w: 0, h: 0 };
    if (!zones[currentPage]) zones[currentPage] = [];
  }
};

overlayCanvas.onmousemove = e => {
  const { x, y } = getPos(e);
  if (isDrawing) {
    activeZone.w = x - startX;
    activeZone.h = y - startY;
    draw();
    overlayCtx.strokeStyle = '#6366f1';
    overlayCtx.strokeRect(startX, startY, activeZone.w, activeZone.h);
  } else if (isDragging) {
    activeZone.x = x - offsetX;
    activeZone.y = y - offsetY;
    draw();
  } else {
    const pageZones = zones[currentPage] || [];
    const isHover = pageZones.some(z => x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h);
    overlayCanvas.style.cursor = isHover ? 'move' : 'crosshair';
  }
};

window.onmouseup = () => {
  if (isDrawing && Math.abs(activeZone.w) > 3) {
    const finalZone = {
      x: activeZone.w > 0 ? activeZone.x : activeZone.x + activeZone.w,
      y: activeZone.h > 0 ? activeZone.y : activeZone.y + activeZone.h,
      w: Math.abs(activeZone.w),
      h: Math.abs(activeZone.h)
    };
    zones[currentPage].push(finalZone);
  }
  isDrawing = isDragging = false;
  activeZone = null;
  draw();
};

prevPageBtn.onclick = () => { if (currentPage > 1) { currentPage--; renderPage(currentPage); } };
nextPageBtn.onclick = () => { if (currentPage < totalPages) { currentPage++; renderPage(currentPage); } };

downloadBtn.onclick = async () => {
  const { PDFDocument, rgb } = PDFLib;
  const pdf = await PDFDocument.load(await pdfFile.arrayBuffer());
  const pages = pdf.getPages();

  pages.forEach((page, i) => {
    const { height } = page.getSize();
    const zs = (applyToAllCheckbox.checked && zones[1]) ? zones[1] : (zones[i+1] || []);
    zs.forEach(z => {
      page.drawRectangle({
        x: z.x / scale,
        y: height - (z.y + z.h) / scale,
        width: z.w / scale,
        height: z.h / scale,
        color: rgb(1,1,1)
      });
    });
  });

  const blob = new Blob([await pdf.save()], {type:'application/pdf'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `edite_${pdfFile.name}`;
  link.click();
};
</script>
</body>
</html>
