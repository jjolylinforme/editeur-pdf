<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Effaceur PDF Simple</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">

  <div class="w-full max-w-4xl bg-white rounded-xl shadow-lg p-6">
    <h1 class="text-xl font-bold text-gray-800 mb-4 tracking-tight">üßº Effaceur PDF</h1>

    <div id="upload-zone" class="border-2 border-dashed border-gray-300 rounded-lg p-10 text-center cursor-pointer hover:bg-gray-50 transition-all">
      <p class="text-gray-600 font-medium font-sans">S√©lectionnez le PDF √† nettoyer</p>
      <input type="file" id="pdfInput" accept=".pdf" class="hidden">
    </div>

    <div id="viewer" class="hidden">
      <div class="flex justify-between items-center bg-gray-50 p-3 rounded-t-lg border border-gray-200 mt-4">
        <div class="flex items-center gap-4">
          <div class="flex gap-1">
            <button id="prevPage" class="px-3 py-1 bg-white border rounded hover:bg-gray-100">‚Üê</button>
            <button id="nextPage" class="px-3 py-1 bg-white border rounded hover:bg-gray-100">‚Üí</button>
          </div>
          <span id="pageInfo" class="text-sm font-bold text-gray-700">Page 1/1</span>
        </div>
        <p class="text-xs text-gray-500 italic">Astuce : Glissez pour effacer, d√©placez les blocs, ou cliquez sur (X) pour annuler.</p>
      </div>

      <div class="bg-gray-200 border border-t-0 border-gray-200 overflow-auto flex justify-center p-4" style="max-height: 65vh;">
        <div class="relative shadow-xl bg-white leading-[0]">
          <canvas id="pdfCanvas"></canvas>
          <canvas id="overlayCanvas" class="absolute top-0 left-0"></canvas>
        </div>
      </div>

      <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6">
        <label class="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
          <input type="checkbox" id="applyToAll" checked class="rounded text-blue-600 focus:ring-blue-500">
          <span>Appliquer ces zones sur tout le document</span>
        </label>
        
        <button id="downloadPDF" class="w-full sm:w-auto px-8 py-3 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 shadow-md transition-all uppercase text-sm tracking-wider">
          T√©l√©charger le PDF final
        </button>
      </div>
    </div>
  </div>

<script>
const pdfInput = document.getElementById('pdfInput');
const uploadZone = document.getElementById('upload-zone');
const viewer = document.getElementById('viewer');
const pdfCanvas = document.getElementById('pdfCanvas');
const overlayCanvas = document.getElementById('overlayCanvas');
const overlayCtx = overlayCanvas.getContext('2d');
const prevPageBtn = document.getElementById('prevPage');
const nextPageBtn = document.getElementById('nextPage');
const pageInfo = document.getElementById('pageInfo');
const applyToAllCheckbox = document.getElementById('applyToAll');
const downloadBtn = document.getElementById('downloadPDF');

let pdfDoc = null, pdfFile = null, currentPage = 1, totalPages = 0, scale = 1.3;
let zones = {}, isDrawing = false, isDragging = false;
let startX = 0, startY = 0, offsetX = 0, offsetY = 0, activeZone = null;

uploadZone.onclick = () => pdfInput.click();
pdfInput.onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  pdfFile = file;
  const arrayBuffer = await file.arrayBuffer();
  pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  totalPages = pdfDoc.numPages;
  viewer.classList.remove('hidden');
  uploadZone.classList.add('hidden');
  renderPage(1);
};

async function renderPage(num) {
  const page = await pdfDoc.getPage(num);
  const viewport = page.getViewport({ scale });
  pdfCanvas.width = overlayCanvas.width = viewport.width;
  pdfCanvas.height = overlayCanvas.height = viewport.height;
  await page.render({ canvasContext: pdfCanvas.getContext('2d'), viewport }).promise;
  draw();
}

function draw() {
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  const pageZones = zones[currentPage] || [];
  
  pageZones.forEach(z => {
    // Le bloc d'effacement
    overlayCtx.fillStyle = 'white';
    overlayCtx.shadowBlur = 4;
    overlayCtx.shadowColor = 'rgba(0,0,0,0.2)';
    overlayCtx.fillRect(z.x, z.y, z.w, z.h);
    overlayCtx.shadowBlur = 0;
    
    // Bordure fine
    overlayCtx.strokeStyle = '#3b82f6';
    overlayCtx.lineWidth = 1;
    overlayCtx.strokeRect(z.x, z.y, z.w, z.h);

    // Bouton de suppression (X)
    overlayCtx.fillStyle = '#ef4444';
    overlayCtx.fillRect(z.x + z.w - 18, z.y, 18, 18);
    overlayCtx.fillStyle = 'white';
    overlayCtx.font = 'bold 12px Arial';
    overlayCtx.fillText('X', z.x + z.w - 13, z.y + 13);
  });
  pageInfo.textContent = `Page ${currentPage}/${totalPages}`;
}

const getPos = (e) => {
  const r = overlayCanvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
};

overlayCanvas.onmousedown = e => {
  const { x, y } = getPos(e);
  const pageZones = zones[currentPage] || [];

  // 1. V√©rifier si on clique sur le (X) pour supprimer
  const zoneToDelete = pageZones.find(z => x >= z.x + z.w - 18 && x <= z.x + z.w && y >= z.y && y <= z.y + 18);
  if (zoneToDelete) {
    zones[currentPage] = pageZones.filter(z => z !== zoneToDelete);
    draw();
    return;
  }

  // 2. V√©rifier si on clique dans une zone pour d√©placer
  const clickedZone = pageZones.find(z => x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h);
  if (clickedZone) {
    activeZone = clickedZone;
    isDragging = true;
    offsetX = x - clickedZone.x;
    offsetY = y - clickedZone.y;
    overlayCanvas.style.cursor = 'move';
  } else {
    // 3. Sinon, on dessine une nouvelle zone
    isDrawing = true;
    startX = x; startY = y;
    activeZone = { x, y, w: 0, h: 0 };
    if (!zones[currentPage]) zones[currentPage] = [];
    overlayCanvas.style.cursor = 'crosshair';
  }
};

overlayCanvas.onmousemove = e => {
  const { x, y } = getPos(e);
  
  if (isDrawing) {
    activeZone.w = x - startX;
    activeZone.h = y - startY;
    draw();
    overlayCtx.strokeStyle = '#3b82f6';
    overlayCtx.strokeRect(startX, startY, activeZone.w, activeZone.h);
  } else if (isDragging) {
    activeZone.x = x - offsetX;
    activeZone.y = y - offsetY;
    draw();
  } else {
    // Change le curseur au survol
    const pageZones = zones[currentPage] || [];
    const isHover = pageZones.some(z => x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h);
    overlayCanvas.style.cursor = isHover ? 'pointer' : 'crosshair';
  }
};

window.onmouseup = () => {
  if (isDrawing) {
    if (Math.abs(activeZone.w) > 5) {
      const finalZone = {
        x: activeZone.w > 0 ? activeZone.x : activeZone.x + activeZone.w,
        y: activeZone.h > 0 ? activeZone.y : activeZone.y + activeZone.h,
        w: Math.abs(activeZone.w),
        h: Math.abs(activeZone.h)
      };
      zones[currentPage].push(finalZone);
    }
  }
  isDrawing = isDragging = false;
  activeZone = null;
  draw();
};

prevPageBtn.onclick = () => { if (currentPage > 1) { currentPage--; renderPage(currentPage); } };
nextPageBtn.onclick = () => { if (currentPage < totalPages) { currentPage++; renderPage(currentPage); } };

downloadBtn.onclick = async () => {
  const { PDFDocument, rgb } = PDFLib;
  const pdf = await PDFDocument.load(await pdfFile.arrayBuffer());
  const pages = pdf.getPages();

  pages.forEach((page, i) => {
    const { height } = page.getSize();
    const zs = (applyToAllCheckbox.checked && zones[1]) ? zones[1] : (zones[i+1] || []);
    zs.forEach(z => {
      page.drawRectangle({
        x: z.x / scale,
        y: height - (z.y + z.h) / scale,
        width: z.w / scale,
        height: z.h / scale,
        color: rgb(1,1,1)
      });
    });
  });

  const blob = new Blob([await pdf.save()], {type:'application/pdf'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `pdf_efface.pdf`;
  link.click();
};
</script>
</body>
</html>
